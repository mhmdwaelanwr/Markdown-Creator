import 'dart:convert';
import 'package:http/http.dart' as http;

class GitHubPublisherService {
  final String token;

  GitHubPublisherService(this.token);

  Future<void> publishReadme({
    required String owner,
    required String repo,
    required String content,
    required String branchName,
    String baseBranch = 'main',
    String commitMessage = 'docs: update README.md via Readme Creator',
    String prTitle = 'Update README.md',
    String prBody = 'This PR updates the README.md file, generated by Readme Creator.',
  }) async {
    final headers = {
      'Authorization': 'Bearer $token',
      'Accept': 'application/vnd.github.v3+json',
      'Content-Type': 'application/json',
    };

    // 1. Get the SHA of the base branch
    final baseRefUrl = Uri.parse('https://api.github.com/repos/$owner/$repo/git/ref/heads/$baseBranch');
    final baseRefResponse = await http.get(baseRefUrl, headers: headers);

    if (baseRefResponse.statusCode != 200) {
      throw Exception('Failed to fetch base branch info: ${baseRefResponse.body}');
    }

    final baseSha = jsonDecode(baseRefResponse.body)['object']['sha'];

    // 2. Create a new branch (reference)
    final newBranchRef = 'refs/heads/$branchName';
    final createRefUrl = Uri.parse('https://api.github.com/repos/$owner/$repo/git/refs');
    final createRefResponse = await http.post(
      createRefUrl,
      headers: headers,
      body: jsonEncode({
        'ref': newBranchRef,
        'sha': baseSha,
      }),
    );

    if (createRefResponse.statusCode != 201) {
      // If branch already exists, we might want to update it or fail.
      // For now, let's assume we want to fail or the user should pick a unique name.
      // Alternatively, we could try to get the SHA of the existing branch.
      throw Exception('Failed to create branch $branchName: ${createRefResponse.body}');
    }

    // 3. Get the SHA of the README.md file if it exists (to update it)
    String? fileSha;
    final fileUrl = Uri.parse('https://api.github.com/repos/$owner/$repo/contents/README.md?ref=$branchName');
    final fileResponse = await http.get(fileUrl, headers: headers);

    if (fileResponse.statusCode == 200) {
      fileSha = jsonDecode(fileResponse.body)['sha'];
    }

    // 4. Create or Update the file
    final updateFileUrl = Uri.parse('https://api.github.com/repos/$owner/$repo/contents/README.md');
    final updateFileResponse = await http.put(
      updateFileUrl,
      headers: headers,
      body: jsonEncode({
        'message': commitMessage,
        'content': base64Encode(utf8.encode(content)),
        'branch': branchName,
        if (fileSha != null) 'sha': fileSha,
      }),
    );

    if (updateFileResponse.statusCode != 200 && updateFileResponse.statusCode != 201) {
      throw Exception('Failed to commit file: ${updateFileResponse.body}');
    }

    // 5. Create Pull Request
    final createPrUrl = Uri.parse('https://api.github.com/repos/$owner/$repo/pulls');
    final createPrResponse = await http.post(
      createPrUrl,
      headers: headers,
      body: jsonEncode({
        'title': prTitle,
        'body': prBody,
        'head': branchName,
        'base': baseBranch,
      }),
    );

    if (createPrResponse.statusCode != 201) {
      throw Exception('Failed to create Pull Request: ${createPrResponse.body}');
    }
  }
}

